"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_hooks_1 = require("@testing-library/react-hooks");
const _1 = require("./");
describe('init', () => {
    const { result } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(10, true));
    it('should set `secondsRemaining`', () => expect(result.current.secondsRemaining).toBe(10));
    it('should set `timeRemaining`', () => expect(result.current.timeRemaining).toBe('00:10'));
    it('should set `isFrozen`', () => expect(result.current.isFrozen).toBe(true));
});
describe('time string', () => {
    it('should return 00:xx seconds', () => {
        const { result } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(10, true));
        expect(result.current.timeRemaining).toBe('00:10');
    });
    it('should return xx:00 minutes and seconds', () => {
        const { result } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(60, true));
        expect(result.current.timeRemaining).toBe('01:00');
    });
    it('should return xx:xx minutes and seconds', () => {
        const { result } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(65, true));
        expect(result.current.timeRemaining).toBe('01:05');
    });
    it('should return 00:00', () => {
        const { result } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(0, true));
        expect(result.current.timeRemaining).toBe('00:00');
    });
});
describe('timer', () => {
    it('should tick down every second', () => __awaiter(void 0, void 0, void 0, function* () {
        const { result, waitForValueToChange } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(3, false));
        for (let i = 3; i > 0; i--) {
            expect(result.current.secondsRemaining).toBe(i);
            expect(result.current.timeRemaining).toBe(`00:${i < 10 ? `0${i}` : i}`);
            yield waitForValueToChange(() => result.current.secondsRemaining);
        }
    }));
    it('should freeze when time is up', () => __awaiter(void 0, void 0, void 0, function* () {
        const { result, waitForValueToChange } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(1, false));
        expect(result.current.isFrozen).toBe(false);
        yield waitForValueToChange(() => result.current.secondsRemaining);
        expect(result.current.isFrozen).toBe(true);
    }));
    it('should call `onCompleted` when time is up', () => __awaiter(void 0, void 0, void 0, function* () {
        const fn = jest.fn();
        const { result, waitForValueToChange } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(1, false, fn));
        expect(fn).not.toHaveBeenCalled();
        yield waitForValueToChange(() => result.current.secondsRemaining);
        expect(fn).toHaveBeenCalledTimes(1);
    }));
    it('should reset', () => __awaiter(void 0, void 0, void 0, function* () {
        const { result, waitForValueToChange } = (0, react_hooks_1.renderHook)(() => (0, _1.useTimer)(1, false));
        expect(result.current.secondsRemaining).toBe(1);
        yield waitForValueToChange(() => result.current.secondsRemaining);
        expect(result.current.secondsRemaining).toBe(0);
        (0, react_hooks_1.act)(() => result.current.resetTimer());
        expect(result.current.secondsRemaining).toBe(1);
    }));
});
